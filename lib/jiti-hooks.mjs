import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import { access, readFile } from "node:fs/promises";
import { createJiti } from "./jiti.mjs";
import { isBuiltin } from "node:module";
import { constants } from "node:fs";

let jiti;

// https://nodejs.org/api/module.html#initialize
export async function initialize() {
  jiti = createJiti();
}

// https://nodejs.org/api/module.html#resolvespecifier-context-nextresolve
export async function resolve(specifier, context, nextResolve) {
  const { shouldSkip, conditions } = _evaluateModule(
    specifier,
    jiti,
    context?.conditions,
  );

  if (shouldSkip) {
    return nextResolve(specifier, context);
  }

  const resolvedPath = jiti.esmResolve(specifier, {
    parentURL: context?.parentURL,
    conditions,
  });

  return {
    url: resolvedPath,
    shortCircuit: true,
  };
}

// https://nodejs.org/api/module.html#loadurl-context-nextload
export async function load(url, context, nextLoad) {
  const { shouldSkip } = _evaluateModule(url, jiti);

  if (shouldSkip) {
    return nextLoad(url, context);
  }

  const filename = fileURLToPath(url);

  if (url.endsWith(".js")) {
    const pkg = await _findClosestPackageJson(dirname(filename));
    if (pkg && pkg.type === "module") {
      return nextLoad(url, context);
    }
  }

  const rawSource = await readFile(filename, "utf8");

  if (url.endsWith(".json")) {
    return {
      source: `export default ${rawSource}`,
      format: "module",
      shortCircuit: true,
    };
  }

  const transpiledSource = jiti.transform({
    source: rawSource,
    filename: filename,
    ts: url.endsWith("ts"),
    retainLines: true,
    async: true,
    jsx: jiti.options.jsx,
  });

  if (url.endsWith(".js") && !transpiledSource.includes("jitiImport")) {
    return {
      source: transpiledSource,
      format: "commonjs",
      shortCircuit: true,
    };
  }

  return {
    source: _wrapSource(transpiledSource, filename),
    format: "module",
    shortCircuit: true,
  };
}

function _wrapSource(source, filename) {
  const _jitiPath = new URL("jiti.mjs", import.meta.url).href;
  return /*js*/ `import { createJiti as __createJiti__ } from ${JSON.stringify(_jitiPath)};async function _module(exports, require, module, __filename, __dirname, jitiImport) { ${source}\n};
// GENERATED BY JITI ESM LOADER
const filename = ${JSON.stringify(filename)};
const dirname = ${JSON.stringify(dirname(filename))};
const jiti = __createJiti__(filename);
const module = { exports: Object.create(null) };
await _module(module.exports, jiti, module, filename, dirname, jiti.import);
if (module.exports && module.exports.__JITI_ERROR__) {
  const { filename, line, column, code, message } =
  module.exports.__JITI_ERROR__;
  const loc = [filename, line, column].join(':');
  const err = new Error(code + ": " + message + " " + loc);
  Error.captureStackTrace(err, _module);
  throw err;
}
export default module.exports;
  `;
}

export function _evaluateModule(url, jiti, conditions) {
  if (!jiti | url.endsWith(".mjs") || url.endsWith(".cjs") || isBuiltin(url)) {
    return {
      shouldSkip: true,
      conditions,
    };
  }

  let matches;

  if (!url.startsWith("./") && !url.startsWith("file://")) {
    matches = jiti.getMatchingConditions(url);

    if (!matches || matches.length === 0) {
      return {
        shouldSkip: true,
        conditions,
      };
    }
  }

  const merge = [...new Set([...(conditions || []), ...(matches || [])])];

  return {
    shouldSkip: false,
    conditions: merge.length > 0 ? merge : undefined,
  };
}

async function _findClosestPackageJson(dir) {
  if (dir === "/") return null;

  const packageJsonPath = join(dir, "package.json");

  if (await _hasAccess(packageJsonPath)) {
    return JSON.parse(await readFile(packageJsonPath, "utf8"));
  }

  return _findClosestPackageJson(dirname(dir));
}

async function _hasAccess(path) {
  return access(path, constants.F_OK)
    .then(() => true)
    .catch(() => false);
}
