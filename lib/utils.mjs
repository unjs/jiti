import { isBuiltin } from "node:module";
import { dirname, join } from "node:path";
import { access, readFile } from "node:fs/promises";
import { accessSync, constants, readFileSync } from "node:fs";

export function evaluateModule(url, jiti, conditions) {
  if (!jiti | url.endsWith(".mjs") || url.endsWith(".cjs") || isBuiltin(url)) {
    return {
      shouldSkip: true,
      conditions,
    };
  }

  let matches;

  if (!url.startsWith("./") && !url.startsWith("file://")) {
    matches = jiti.getMatchingConditions(url);

    if (!matches || matches.length === 0) {
      return {
        shouldSkip: true,
        conditions,
      };
    }
  }

  const merge = [...new Set([...(conditions || []), ...(matches || [])])];

  return {
    shouldSkip: false,
    conditions: merge.length > 0 ? merge : undefined,
  };
}

export function wrapSource(source, filename, type, base) {
  const _jitiPath = new URL("jiti.mjs", base).href;

  switch (type) {
    case "async": {
      return /*js*/ `import { createJiti as __createJiti__ } from ${JSON.stringify(_jitiPath)};async function _module(exports, require, module, __filename, __dirname, jitiImport) { ${source}\n};
// GENERATED BY JITI ESM LOADER
const filename = ${JSON.stringify(filename)};
const dirname = ${JSON.stringify(dirname(filename))};
const jiti = __createJiti__(filename);
const module = { exports: Object.create(null) };
await _module(module.exports, jiti, module, filename, dirname, jiti.import);
if (module.exports && module.exports.__JITI_ERROR__) {
  const { filename, line, column, code, message } =
  module.exports.__JITI_ERROR__;
  const loc = [filename, line, column].join(':');
  const err = new Error(code + ": " + message + " " + loc);
  Error.captureStackTrace(err, _module);
  throw err;
}
export default module.exports;
  `;
    }

    case "sync": {
      return /*js*/ `import { createJiti as __createJiti__ } from ${JSON.stringify(_jitiPath)};function _module(exports, require, module, __filename, __dirname, jitiImport) { ${source}\n};
// GENERATED BY JITI ESM LOADER
const filename = ${JSON.stringify(filename)};
const dirname = ${JSON.stringify(dirname(filename))};
const jiti = __createJiti__(filename);
const module = { exports: Object.create(null) };
_module(module.exports, jiti, module, filename, dirname, jiti.import);
if (module.exports && module.exports.__JITI_ERROR__) {
  const { filename, line, column, code, message } =
  module.exports.__JITI_ERROR__;
  const loc = [filename, line, column].join(':');
  const err = new Error(code + ": " + message + " " + loc);
  Error.captureStackTrace(err, _module);
  throw err;
}
export default module.exports;
  `;
    }

    default: {
      throw new Error(
        'Invalid type provided to wrapSource. Expected "async" or "sync".',
      );
    }
  }
}

export async function hasAccess(path) {
  return access(path, constants.F_OK)
    .then(() => true)
    .catch(() => false);
}

export function hasAccessSync(path) {
  try {
    accessSync(path, constants.F_OK);
    return true;
  } catch {
    return false;
  }
}

export async function findClosestPackageJson(dir) {
  if (dir === "/") return null;

  const packageJsonPath = join(dir, "package.json");

  if (await hasAccess(packageJsonPath)) {
    return JSON.parse(await readFile(packageJsonPath, "utf8"));
  }

  return findClosestPackageJson(dirname(dir));
}

export function findClosestPackageJsonSync(dir) {
  if (dir === "/") return null;

  const packageJsonPath = join(dir, "package.json");

  if (hasAccessSync(packageJsonPath)) {
    return JSON.parse(readFileSync(packageJsonPath, "utf8"));
  }

  return findClosestPackageJsonSync(dirname(dir));
}
